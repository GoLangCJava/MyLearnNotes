# MySQL 学习笔记

## SQL 语句与种类

- DDL（Data Definition Language）数据库定义语言：如 create drop alter
- DML（Data Manipulation Language）数据操纵语言：如 select insert update delete
- DCL（Data Control Language）数据控制语言：如 commit rollback grant revoke

我们使用的 SQL 语句中，有 90% 属于 DML

## MySQL 数据类型

整数类型：

|           类型           | 占用的存储空间（单位：字节） | 无符号数取值范围 | 有符号数取值范围 |      含义      |
| :----------------------: | :--------------------------: | :--------------: | :--------------: | :------------: |
|        `TINYINT`         |              1               |     0 ~ 2⁸-1     |    -2⁷ ~ 2⁷-1    |  非常小的整数  |
|        `SMALLINT`        |              2               |    0 ~ 2¹⁶-1     |   -2¹⁵ ~ 2¹⁵-1   |    小的整数    |
|       `MEDIUMINT`        |              3               |    0 ~ 2²⁴-1     |   -2²³ ~ 2²³-1   | 中等大小的整数 |
| `INT`（别名：`INTEGER`） |              4               |    0 ~ 2³²-1     |   -2³¹ ~ 2³¹-1   |   标准的整数   |
|         `BIGINT`         |              8               |    0 ~ 2⁶⁴-1     |   -2⁶³ ~ 2⁶³-1   |     大整数     |

浮点类型：

|   类型   | 占用的存储空间（单位：字节） |     绝对值最小非0值      |     绝对值最大非0值      |     含义     |
| :------: | :--------------------------: | :----------------------: | :----------------------: | :----------: |
| `FLOAT`  |              4               |     ±1.175494351E-38     |     ±3.402823466E+38     | 单精度浮点数 |
| `DOUBLE` |              8               | ±2.2250738585072014E-308 | ±1.7976931348623157E+308 | 双精度浮点数 |

定点数类型：

|      类型       | 占用的存储空间（单位：字节） |  取值范围  |
| :-------------: | :--------------------------: | :--------: |
| `DECIMAL(M, D)` |          取决于M和D          | 取决于M和D |

日期和时间类型：

|    类型     | 存储空间要求 |                    取值范围                    |     含义     |
| :---------: | :----------: | :--------------------------------------------: | :----------: |
|   `YEAR`    |    1字节     |                   1901~2155                    |    年份值    |
|   `DATE`    |    3字节     |          '1000-01-01' ~ '9999-12-31'           |    日期值    |
|   `TIME`    |    3字节     |           '-838:59:59' ~ '838:59:59'           |    时间值    |
| `DATETIME`  |    8字节     | '1000-01-01 00:00:00' ～ '9999-12-31 23:59:59' | 日期加时间值 |
| `TIMESTAMP` |    4字节     | '1970-01-01 00:00:01' ～ '2038-01-19 03:14:07' |    时间戳    |

字符串类型：

|     类型     |   最大长度   |   存储空间要求    |       含义       |
| :----------: | :----------: | :---------------: | :--------------: |
|  `CHAR(M)`   |   M个字符    |     M×W个字节     | 固定长度的字符串 |
| `VARCHAR(M)` |   M个字符    | L+1 或 L+2 个字节 | 可变长度的字符串 |
|  `TINYTEXT`  | 2⁸-1 个字节  |     L+1个字节     | 非常小型的字符串 |
|    `TEXT`    | 2¹⁶-1 个字节 |    L+2 个字节     |   小型的字符串   |
| `MEDIUMTEXT` | 2²⁴-1 个字节 |     L+3个字节     | 中等大小的字符串 |
|  `LONGTEXT`  | 2³²-1 个字节 |     L+4个字节     |   大型的字符串   |

枚举类型ENUM：它表示在给定的字符串列表里选择一个

```
ENUM('str1', 'str2', 'str3' ⋯)
```

SET类型，表示在给定的字符串列表里选择多个：

```
SET('str1', 'str2', 'str3' ⋯)
```

二进制类型：

|   类型   |    字节数     |       含义        |
| :------: | :-----------: | :---------------: |
| `BIT(M)` | 近似为(M+7)/8 | 存储M个比特位的值 |

## 数据库的基本操作

- 展示数据库：`SHOW DATABASES;`
- 创建数据库：`CREATE DATABASE 数据库名;`，可以在创建前先判断是否存在 `CREATE DATABASE IF NOT EXISTS 数据库名;`
- 切换数据库：`USE 数据库名称;`
- 删除数据库：`DROP DATABASE 数据库名;`，可以先判断是否存在：`DROP DATABASE IF EXISTS 数据库名;`

## 表的基本操作

- 展示数据库中有哪些表：`SHOW TABLES;`

- 创建表：

  ```sql
  CREATE TABLE 表名 (
      列名1    数据类型    [列的属性],
      列名2    数据类型    [列的属性],
      ...
      列名n    数据类型    [列的属性]
  );
  
  CREATE TABLE 表名 (
      各个列的信息 ...
  ) COMMENT '表的注释信息';
  
  CREATE TABLE IF NOT EXISTS 表名(
      各个列的信息 ...
  );
  ```

- 删除表：`DROP TABLE 表1, 表2, ..., 表n;`

- 查看表结构：

  ```sql
  DESCRIBE 表名;
  DESC 表名;
  EXPLAIN 表名;
  SHOW COLUMNS FROM 表名;
  SHOW FIELDS FROM 表名;
  ```

### 查看表创建语句: 

```sql
SHOW CREATE TABLE 表名; 
SHOW CREATE TABLE 表名\G; # 显示效果好点
```

### 使用`utf8`字符集建库

utf8字符集是残缺的只有三个字节，utf8mb4 占4个字节，里面可以存储所有的utf8字符。

```sql
create database xiaohaizi character set utf8mb4;
create database IF NOT EXISTS xiaohaizi character set utf8mb4; # 不存在才建立
```

### 修改表名

```sql
ALTER TABLE 旧表名 RENAME TO 新表名;
RENAME TABLE 旧表名1 TO 新表名1, 旧表名2 TO 新表名2, ... 旧表名n TO 新表名n;
```

还可以把一个数据库中的表转移到另一个数据库中：

```sql
RENAME TABLE dahaizi.first_table1 TO xiaohaizi.first_table;
```

### 增加表中的列

```sql
ALTER TABLE 表名 ADD COLUMN 列名 数据类型 [列的属性];

例子：
ALTER TABLE first_table ADD COLUMN third_column CHAR(4) ;
```

默认mysql会添加在最后一列，如果想要添加到第一列，可以这样：

```sql
ALTER TABLE 表名 ADD COLUMN 列名 列的类型 [列的属性] FIRST;
```

添加在指定列名的后面：

```sql
ALTER TABLE 表名 ADD COLUMN 列名 列的类型 [列的属性] AFTER 指定列名;
```

### 删除列

```sql
ALTER TABLE 表名 DROP COLUMN 列名;
```

### 修改列的信息：

方式1：

```sql
ALTER TABLE 表名 MODIFY 列名 新数据类型 [新属性];
```

注意：修改后的数据类型和属性一定要兼容表中现有的数据

方式2：

这种修改方式需要我们填两个列名，也就是说在修改数据类型和属性的同时也可以修改列名

```sql
ALTER TABLE 表名 CHANGE 旧列名 新列名 新数据类型 [新属性];
```

### 修改列排列位置

将列设为表的第一列：

```sql
ALTER TABLE 表名 MODIFY 列名 列的类型 列的属性 FIRST;
```

将列放到指定列的后边：

```sql
ALTER TABLE 表名 MODIFY 列名 列的类型 列的属性 AFTER 指定列名;
```

### 一条语句中包含多个修改操作

如果对同一个表有多个修改操作的话，我们可以把它们放到一条语句中执行，就像这样：

```sql
ALTER TABLE 表名 操作1, 操作2, ..., 操作n;
```

## 列的属性

简单查询语句：

```sql
SELECT * FROM 表名;
```

简单插入语句：

```sql
INSERT INTO 表名(列1, 列2, ...) VALUES(列1的值，列2的值, ...);
# 批量插入
INSERT INTO 表名(列1,列2, ...) VAULES(列1的值，列2的值, ...), (列1的值，列2的值, ...), (列1的值，列2的值, ...), ...;
```

### 默认值

在书写`INSERT`语句插入记录的时候可以只指定部分的列，那些没有被显式指定的列的值将被设置为`NULL`，换一种说法就是列的默认值为`NULL`，`NULL`的含义是这个列的值还没有被设置。如果我们不想让默认值为`NULL`，而是设置成某个有意义的值，可以在定义列的时候给该列增加一个`DEFAULT`属性，就像这样：

```sql
列名 列的类型 DEFAULT 默认值
```

### NOT NULL属性

有时候我们需要要求表中的某些列中必须有值，不能存放`NULL`，那么可以用这样的语法来定义这个列：

```
列名 列的类型 NOT NULL
```

### 主键

有时候在我们的表里可以通过某个列或者某些列确定唯一的一条记录，我们就可以把这个列或者这些列称为`候选键`。比如在学生信息表`student_info`中，只要我们知道某个学生的学号，就可以确定一个唯一的学生信息，也就是一条记录。当然，我们也可以通过身份证号来确定唯一的一条学生信息记录，所以`学号`和`身份证号`都可以作为学生信息表的`候选键`。在学生成绩表`student_score`中，我们可以通过`学号`和`科目`这两个列的组合来确定唯一的一条成绩记录，所以`学号、科目`这两个列的组合可以作为学生成绩表的`候选键`。

**一个表可能有多个候选键，我们可以选择一个候选键作为表的`主键`。一个表最多只能有一个主键，主键的值不能重复，通过主键可以找到唯一的一条记录**

主键可以通过两种方式进行声明：

1. 如果主键只是单个列的话，可以直接在该列后声明`PRIMARY KEY`

2. 也可以把主键的声明单独提取出来，用这样的形式声明：

   ```sql
   PRIMARY KEY (列名1, 列名2, ...)
   ```

   对于多个列的组合作为主键的情况，必须使用这种单独声明的形式

主键默认具有 `NOT NULL` 属性。

### UNIQUE属性

对于不是主键的其他候选键，如果也想让`MySQL`在我们向表中插入新记录的时候帮助我们校验一下某个列或者列组合的值是否重复，那么我们可以把这个列或列组合添加一个`UNIQUE`属性，表明该列或者列组合的值是不允许重复的。

声明方式也是两种：

1. 如果我们想为单个列声明`UNIQUE`属性，可以直接在该列后填写`UNIQUE`或者`UNIQUE KEY`

2. 也可以把`UNIQUE`属性的声明单独提取出来

   ```
   UNIQUE [约束名称] (列名1, 列名2, ...)
   或
   UNIQUE KEY [约束名称] (列名1, 列名2, ...)
   ```

如果表中为某个列或者列组合定义了`UNIQUE`属性的话，`MySQL`会对我们插入的记录做校验，如果新插入记录在该列或者列组合的值已经在表中存在了，那就会报错！

### 主键和UNIQUE约束的区别

1. 一张表中只能定义一个主键，却可以定义多个`UNIQUE`约束！
2. 规定：主键列不允许存放NULL，而声明了`UNIQUE`属性的列可以存放`NULL`，而且`NULL`可以重复地出现在多条记录中！

### 外键

定义外键的语法：

```sql
CONSTRAINT [外键名称] FOREIGN KEY(列1, 列2, ...) REFERENCES 父表名(父列1, 父列2, ...);
```

其中的`外键名称`也是可选的。如果A表中的某个列或者某些列依赖与B表中的某个列或者某些列，那么就称A表为`子表`，B表为`父表`。子表和父表可以使用外键来关联起来。

> 父表中被子表依赖的列或者列组合必须建立索引，如果该列或者列组合已经是主键或者有UNIQUE属性，那么它们也就被默认建立了索引。示例中student_score表依赖于stuent_info表的number列，而number列又是stuent_info的主键（注意上一章定义的student_info结构中没有把number列定义为主键，本章才将其定义为主键，如果你的机器上还没有将其定义为主键的话，赶紧修改表结构呗～），所以在student_score表中创建外键是没问题的。

### AUTO_INCREMENT属性

`AUTO_INCREMENT`翻译成中文可以理解为`自动增长`，简称自增。如果一个表中的某个列的数据类型是整数类型或者浮点数类型，那么这个列可以设置`AUTO_INCREMENT`属性。当我们把某个列设置了`AUTO_INCREMENT`属性之后，如果我们在插入新记录的时候不指定该列的值，或者将该列的值显式地指定为`NULL`或者`0`，那么新插入的记录在该列上的值就是当前该列的最大值加1后的值，定义语法为：

```
列名 列的类型 AUTO_INCREMENT
```

列`id`是从1开始递增的。在为列定义`AUTO_INCREMENT`属性的时候需要注意这几点：

1. 一个表中最多有一个具有AUTO_INCREMENT属性的列。
2. 具有AUTO_INCREMENT属性的列必须建立索引。主键和具有`UNIQUE`属性的列会自动建立索引。不过至于什么是索引，在学习MySQL进阶的时候才会介绍。
3. 拥有AUTO_INCREMENT属性的列就不能再通过指定DEFAULT属性来指定默认值。
4. 一般拥有AUTO_INCREMENT属性的列都是作为主键的属性，来自动生成唯一标识一条记录的主键值。

### 列的注释

上一章中我们说了在建表语句的末尾可以添加`COMMENT`语句来给表添加注释，其实我们也可以在每一个列末尾添加`COMMENT`语句来为列来添加注释，比方说：

```
CREATE TABLE first_table (
    id int UNSIGNED AUTO_INCREMENT PRIMARY KEY COMMENT '自增主键',
    first_column INT COMMENT '第一列',
    second_column VARCHAR(100) DEFAULT 'abc' COMMENT '第二列'
) COMMENT '第一个表';
```

### 影响展示外观的ZEROFILL属性

下边是正整数`3`的三种写法：

- 写法一：`3`
- 写法二：`003`
- 写法三：`000003`

对于无符号整数类型的列，我们可以在查询数据的时候让数字左边补0，如果想实现这个效果需要给该列加一个`ZEROFILL`属性（也可以理解为这是一个属于数据类型的属性），就像这样：

```
mysql> CREATE TABLE zerofill_table (
    ->     i1 INT UNSIGNED ZEROFILL,
    ->     i2 INT UNSIGNED
    -> );
Query OK, 0 rows affected (0.03 sec)
```

`显示宽度`。`显示宽度`是在查询语句显示的结果中，如果声明了 **ZEROFILL** 属性的整数列的实际值的位数小于显示宽度时，会在实际值的左侧补0，使补0的位数和实际值的位数相加正好等于显示宽度。我们也可以自己指定显示宽度

- 在展示查询结果时，某列数据自动补0的条件有这几个：

  - 该列必须是整数类型的
  - 该列必须有`UNSIGNED ZEROFILL`的属性
  - 该列的实际值的位数必须小于显示宽度

- 在创建表的时候，如果声明了`ZEROFILL`属性的列没有声明`UNSIGNED`属性，那`MySQL`会为该列自动生成`UNSIGNED`属性。

  也就是说如果我们创建表语句是这样的：

  ```
  CREATE TABLE zerofill_table (
      i1 INT ZEROFILL,
      i2 INT UNSIGNED
  );
  ```

  `MySQL`会自动帮我们为`i1`列加上`UNSIGNED`属性，也就是这样：

  ```
  CREATE TABLE zerofill_table (
      i1 INT UNSIGNED ZEROFILL,
      i2 INT UNSIGNED
  );
  ```

  也就是说`MySQL`现在只支持对无符号整数进行自动补0的操作。

- 每个整数类型都会有默认的显示宽度。

  比如`TINYINT`的默认显示宽度是`4`，`INT`的默认显示宽度是`(11)`... 如果加了`UNSIGNED`属性，则该类型的显示宽度减1，比如`TINYINT UNSIGNED`的显示宽度是`3`，`INT UNSIGNED`的显示宽度是`10`。

- 显示宽度并不会影响实际类型的实际存储空间。

  显示宽度仅仅是在展示查询结果时，如果整数的位数不够显示宽度的情况下起作用的，并不影响该数据类型要求的存储空间以及该类型能存储的数据范围，也就是说`INT(1)`和`INT(10)`仅仅在展示时可能有区别，在别的方面没有任何区别。比方说`zerofill_table`表中`i1`列的显示宽度是5，而数字`12345678`的位数是8，它照样可以被填入`i1`列中：

  ```
  mysql> INSERT INTO zerofill_table(i1, i2) VALUES(12345678, 12345678);
  Query OK, 1 row affected (0.01 sec)
  
  mysql>
  ```

- 只有列的实际值的位数小于显示宽度时才会补0，实际值的位数大于显示宽度时照原样输出。

  比方说我们刚刚把`12345678`存到了`i1`列里，在展示这个值时，并不会截短显示的数据，而是照原样输出：

  ```
  mysql> SELECT * FROM zero_table;
  +----------+----------+
  | i1       | i2       |
  +----------+----------+
  |    00001 |        1 |
  | 12345678 | 12345678 |
  +----------+----------+
  2 rows in set (0.00 sec)
  
  mysql>
  ```

- 对于没有声明`ZEROFILL`属性的列，显示宽度没有一毛钱卵用。

  只有在查询声明了`ZEROFILL`属性的列时，显示宽度才会起作用，否则忽略显示宽度这个东西的存在。

### 一个列同时具有多个属性

每个列可以同时具有多个属性，属性声明的顺序无所谓，各个属性之间用空白隔开就好了～

### 查看表结构时的列属性

```
mysql> DESC student_info;
+-----------------+-------------------+------+-----+---------+-------+
| Field           | Type              | Null | Key | Default | Extra |
+-----------------+-------------------+------+-----+---------+-------+
| number          | int(11)           | NO   | PRI | NULL    |       |
| name            | varchar(5)        | YES  |     | NULL    |       |
| sex             | enum('男','女')   | YES  |     | NULL    |       |
| id_number       | char(18)          | YES  | UNI | NULL    |       |
| department      | varchar(30)       | YES  |     | NULL    |       |
| major           | varchar(30)       | YES  |     | NULL    |       |
| enrollment_time | date              | YES  |     | NULL    |       |
+-----------------+-------------------+------+-----+---------+-------+
7 rows in set (0.00 sec)

mysql>
```

可以看到：

- `NULL`列代表该列是否可以存储`NULL`，值为`NO`时，表示不允许存储`NULL`，值为`YES`是表示可以存储`NULL`。
- `Key`列存储关于所谓的`键`的信息，当值为`PRI`是`PRIMARY KEY`的缩写，代表主键；`UNI`是`UNIQUE KEY`的缩写，代表`UNIQUE`属性。
- `Default`列代表该列的默认值。
- `Extra`列展示一些额外的信息。比方说如果某个列具有`AUTO_INCREMENT`属性就会被展示在这个列里。