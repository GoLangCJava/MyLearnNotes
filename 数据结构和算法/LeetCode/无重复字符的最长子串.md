题目链接：[无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。

**示例 1:**

```
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**示例 2:**

```
输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

**示例 3:**

```
输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

## 思路

看一眼这个题，肯定能一眼想到暴力解法$O(n^2)$去枚举，那么我们想一下这个过程可以可以优化。

题目中想要使得子串长度最大，那么我们对于每一个位置的字符，肯定是尽量的向左右扩展。我们从左到右去找，那么左边已经被我们考虑了，我们只需要尽量向右扩展就行，题目就变成了：以当前点为起点，向右最多扩展多少个字符，且其中不含重复字符。

我们可以用双指针滑动窗口来解决这个问题，设定指针`l`和`r`开始都在起点，尽量向右扩展，扩展不动时证明存在重复字符了，那么我们就移动左边指针，直到不包含重复字符为止，再继续向右扩展。期间记录有没有重复字符可以用一个`hash`来记录，这个过程中实时保存`r-l+1`的最大值即可。

## 代码

```cpp
class Solution
{
public:
    int lengthOfLongestSubstring(string s)
    {
        unordered_map<char, int> mp;
        int maxx = 0, l = 0, r = 0;
        while (l <= r && r < s.length())
        {
            if (mp[s[r]] > 0)
                mp[s[l++]]--;
            else
            {
                maxx = max(maxx, r - l + 1);
                mp[s[r++]]++;
            }
        }
        return maxx;
    }
};
```



