题目链接：[最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**示例:**

```
输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

**进阶:**

如果你已经实现复杂度为 O(*n*) 的解法，尝试使用更为精妙的分治法求解。

## 思路

首先我们假设数组中的数至少有一个正数。那么我们每次累加的时候，如果发现当前的和小于`0`，那就把和置为`0`。原因是因为数组中至少有一个正数，所以我们至少保证我们的最大值是一个正数（只选那歌正数），所以负值可以舍弃。然后累加的过程中记录当前的最大值即可。

刚刚讨论了至少存在一个正数的情形，那么序列如果全部是负数呢，很容易想到，我们只需要找到这些数中最大的数就是答案。

算法总的时间复杂度$O(n)$，空间复杂度$O(1)$

## 代码

```cpp
class Solution
{
public:
    int maxSubArray(vector<int> &nums)
    {
        int sum = 0, maxx = -2147483647;
        // tmp用于找出数组中最大的，flag来确定数组中有没有正数
        int tmp = -2147483647, flag = 0;
        for (auto num : nums)
        {
            if (num > 0)
                flag = 1;
            tmp = max(tmp, num);
            sum += num;
            if (sum < 0)
                sum = 0;
            maxx = max(maxx, sum);
        }
        return flag == 0 ? tmp : maxx;
    }
};
```

